#!/usr/bin/env python3
"""
Apply Spotify enrichment data from CSV to the production database.

This script:
1. Reads a CSV file generated by fetch_spotify_metadata.py
2. Bulk updates the database with spotify_popularity and isrc values
3. Validates the updates with count checks
4. Reports statistics

Usage:
    python apply_spotify_enrichment.py data/spotify_enrichment_YYYYMMDD_HHMMSS.csv
"""
import os
import csv
import sys
from pathlib import Path
from typing import List, Dict, Tuple
from dotenv import load_dotenv
from utils.db import get_db_connection

# Load environment variables from parent directory
env_path = Path(__file__).parent.parent / '.env'
if env_path.exists():
    load_dotenv(env_path)

env_local_path = Path(__file__).parent.parent / '.env.local'
if env_local_path.exists():
    load_dotenv(env_local_path)

# Construct DATABASE_URL if not already set
if not os.getenv('DATABASE_URL'):
    db_password = os.getenv('DB_PASSWORD')
    supabase_url = os.getenv('NEXT_PUBLIC_SUPABASE_URL')

    if db_password and supabase_url:
        project_ref = supabase_url.replace('https://', '').split('.')[0]
        database_url = f"postgresql://postgres:{db_password}@db.{project_ref}.supabase.co:6543/postgres"
        os.environ['DATABASE_URL'] = database_url


def read_csv(csv_path: Path) -> List[Dict]:
    """
    Read enrichment data from CSV file.

    Args:
        csv_path: Path to CSV file

    Returns:
        List of dicts with track enrichment data
    """
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV file not found: {csv_path}")

    data = []
    with open(csv_path, 'r', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)

        for row in reader:
            # Convert empty strings to None
            popularity = row['spotify_popularity']
            isrc = row['isrc']

            data.append({
                'track_id': row['track_id'],
                'spotify_id': row['spotify_id'],
                'spotify_popularity': int(popularity) if popularity else None,
                'isrc': isrc if isrc else None
            })

    return data


def get_current_stats() -> Tuple[int, int]:
    """
    Get current count of tracks with popularity and ISRC.

    Returns:
        Tuple of (tracks_with_popularity, tracks_with_isrc)
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()

        cursor.execute("SELECT COUNT(*) FROM tracks WHERE spotify_popularity IS NOT NULL")
        popularity_count = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM tracks WHERE isrc IS NOT NULL")
        isrc_count = cursor.fetchone()[0]

        cursor.close()

    return popularity_count, isrc_count


def bulk_update_tracks(data: List[Dict]) -> Tuple[int, int]:
    """
    Bulk update tracks with spotify_popularity and isrc values.

    Args:
        data: List of dicts with track enrichment data

    Returns:
        Tuple of (popularity_updates, isrc_updates)
    """
    from psycopg2.extras import execute_values

    popularity_updates = 0
    isrc_updates = 0

    with get_db_connection() as conn:
        cursor = conn.cursor()

        # Prepare data for bulk update
        # We'll do two separate updates: one for popularity, one for ISRC

        # Update popularity
        popularity_data = [
            (row['spotify_popularity'], row['track_id'])
            for row in data
            if row['spotify_popularity'] is not None
        ]

        if popularity_data:
            execute_values(
                cursor,
                """
                UPDATE tracks AS t
                SET spotify_popularity = v.popularity
                FROM (VALUES %s) AS v(popularity, track_id)
                WHERE t.id = v.track_id::uuid
                """,
                popularity_data,
                page_size=1000
            )
            popularity_updates = len(popularity_data)
            print(f"  ✓ Updated spotify_popularity for {popularity_updates} tracks")

        # Update ISRC
        isrc_data = [
            (row['isrc'], row['track_id'])
            for row in data
            if row['isrc'] is not None
        ]

        if isrc_data:
            execute_values(
                cursor,
                """
                UPDATE tracks AS t
                SET isrc = v.isrc
                FROM (VALUES %s) AS v(isrc, track_id)
                WHERE t.id = v.track_id::uuid
                """,
                isrc_data,
                page_size=1000
            )
            isrc_updates = len(isrc_data)
            print(f"  ✓ Updated isrc for {isrc_updates} tracks")

        cursor.close()

    return popularity_updates, isrc_updates


def main():
    """Main entry point."""
    print("Spotify Enrichment Application Script")
    print("=" * 80)

    # Check for CSV file argument
    if len(sys.argv) < 2:
        print("Usage: python apply_spotify_enrichment.py <csv_file>")
        print("\nExample:")
        print("  python apply_spotify_enrichment.py data/spotify_enrichment_20251130_120000.csv")
        return

    csv_path = Path(sys.argv[1])

    # Read CSV
    print(f"\nReading CSV file: {csv_path}")
    try:
        data = read_csv(csv_path)
    except FileNotFoundError as e:
        print(f"✗ Error: {e}")
        return
    except Exception as e:
        print(f"✗ Error reading CSV: {e}")
        return

    print(f"✓ Loaded {len(data)} records from CSV")

    # Count records with data
    popularity_records = sum(1 for row in data if row['spotify_popularity'] is not None)
    isrc_records = sum(1 for row in data if row['isrc'] is not None)

    print(f"\nRecords to update:")
    print(f"  - spotify_popularity: {popularity_records}")
    print(f"  - isrc: {isrc_records}")

    # Get current database stats
    print("\nCurrent database stats:")
    current_pop, current_isrc = get_current_stats()
    print(f"  - Tracks with spotify_popularity: {current_pop}")
    print(f"  - Tracks with isrc: {current_isrc}")

    # Confirm with user
    print("\n" + "=" * 80)
    print("⚠  WARNING: This will update the production database!")
    print("=" * 80)
    confirmation = input("\nProceed with update? (yes/no): ").strip().lower()

    if confirmation != 'yes':
        print("Update cancelled.")
        return

    # Perform update
    print("\nApplying updates to database...")
    try:
        popularity_updates, isrc_updates = bulk_update_tracks(data)
    except Exception as e:
        print(f"\n✗ Error updating database: {e}")
        print("Update rolled back.")
        return

    # Verify updates
    print("\nVerifying updates...")
    new_pop, new_isrc = get_current_stats()

    print("\n" + "=" * 80)
    print("UPDATE SUMMARY")
    print("=" * 80)
    print(f"Spotify Popularity:")
    print(f"  - Before: {current_pop} tracks")
    print(f"  - After:  {new_pop} tracks")
    print(f"  - Change: +{new_pop - current_pop}")
    print()
    print(f"ISRC:")
    print(f"  - Before: {current_isrc} tracks")
    print(f"  - After:  {new_isrc} tracks")
    print(f"  - Change: +{new_isrc - current_isrc}")
    print("=" * 80)

    # Final validation
    if popularity_updates == (new_pop - current_pop) and isrc_updates == (new_isrc - current_isrc):
        print("\n✓ Update successful! All records updated as expected.")
    else:
        print("\n⚠  Warning: Update counts don't match expected values.")
        print("Please verify the database state.")

    print("\n" + "=" * 80)
    print("NEXT STEPS")
    print("=" * 80)
    print("1. Verify data in the database:")
    print("   SELECT spotify_popularity, isrc FROM tracks LIMIT 10;")
    print()
    print("2. Generate updated TypeScript types:")
    print("   pnpm db:generate-types")
    print("=" * 80)


if __name__ == '__main__':
    main()
